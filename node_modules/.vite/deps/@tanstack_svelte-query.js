import "./chunk-X7HCJ7ZS.js";
import {
  CancelledError,
  InfiniteQueryObserver,
  MutationCache,
  MutationObserver,
  QueriesObserver,
  Query,
  QueryCache,
  QueryClient,
  QueryObserver,
  defaultShouldDehydrateMutation,
  defaultShouldDehydrateQuery,
  dehydrate,
  focusManager,
  hashQueryKey,
  hydrate,
  isCancelledError,
  isError,
  isServer,
  matchQuery,
  notifyManager,
  onlineManager,
  parseFilterArgs,
  parseMutationArgs,
  parseMutationFilterArgs,
  parseQueryArgs,
  replaceEqualDeep
} from "./chunk-NMCAG6C7.js";
import "./chunk-TDRWH72F.js";
import {
  derived,
  readable
} from "./chunk-L4RHR4OE.js";
import {
  SvelteComponentDev,
  create_slot,
  dispatch_dev,
  getContext,
  get_all_dirty_from_scope,
  get_slot_changes,
  init,
  onDestroy,
  onMount,
  safe_not_equal,
  setContext,
  transition_in,
  transition_out,
  update_slot_base,
  validate_slots
} from "./chunk-663KAPRR.js";
import "./chunk-XSLCAIPP.js";
import "./chunk-TYRVL62N.js";

// node_modules/@tanstack/svelte-query/build/lib/context.js
var _contextKey = "$$_queryClient";
var getQueryClientContext = () => {
  const client = getContext(_contextKey);
  if (!client) {
    throw new Error("No QueryClient was found in Svelte context. Did you forget to wrap your component with QueryClientProvider?");
  }
  return client;
};
var setQueryClientContext = (client) => {
  setContext(_contextKey, client);
};

// node_modules/@tanstack/svelte-query/build/lib/useQueryClient.js
function useQueryClient() {
  const queryClient = getQueryClientContext();
  return queryClient;
}

// node_modules/@tanstack/svelte-query/build/lib/createBaseQuery.js
function createBaseQuery(options, Observer) {
  const queryClient = useQueryClient();
  const defaultedOptions = queryClient.defaultQueryOptions(options);
  defaultedOptions._optimisticResults = "optimistic";
  let observer = new Observer(queryClient, defaultedOptions);
  if (defaultedOptions.onError) {
    defaultedOptions.onError = notifyManager.batchCalls(defaultedOptions.onError);
  }
  if (defaultedOptions.onSuccess) {
    defaultedOptions.onSuccess = notifyManager.batchCalls(defaultedOptions.onSuccess);
  }
  if (defaultedOptions.onSettled) {
    defaultedOptions.onSettled = notifyManager.batchCalls(defaultedOptions.onSettled);
  }
  readable(observer).subscribe(($observer) => {
    observer = $observer;
    observer.setOptions(defaultedOptions, { listeners: false });
  });
  const result = readable(observer.getCurrentResult(), (set) => {
    return observer.subscribe(notifyManager.batchCalls(set));
  });
  const { subscribe } = derived(result, ($result) => {
    $result = observer.getOptimisticResult(defaultedOptions);
    return !defaultedOptions.notifyOnChangeProps ? observer.trackResult($result) : $result;
  });
  return { subscribe };
}

// node_modules/@tanstack/svelte-query/build/lib/createQuery.js
function createQuery(arg1, arg2, arg3) {
  const parsedOptions = parseQueryArgs(arg1, arg2, arg3);
  const result = createBaseQuery(parsedOptions, QueryObserver);
  return result;
}

// node_modules/@tanstack/svelte-query/build/lib/createQueries.js
function createQueries(queries) {
  const client = useQueryClient();
  function getDefaultQuery(newQueries) {
    return newQueries.map((options) => {
      const defaultedOptions = client.defaultQueryOptions(options);
      defaultedOptions._optimisticResults = "optimistic";
      return defaultedOptions;
    });
  }
  const defaultedQueries = getDefaultQuery(queries);
  let observer = new QueriesObserver(client, defaultedQueries);
  readable(observer).subscribe(($observer) => {
    observer = $observer;
    observer.setQueries(defaultedQueries, { listeners: false });
  });
  const { subscribe } = readable(observer.getOptimisticResult(defaultedQueries), (set) => {
    return observer.subscribe(notifyManager.batchCalls(set));
  });
  return { subscribe };
}

// node_modules/@tanstack/svelte-query/build/lib/createInfiniteQuery.js
function createInfiniteQuery(arg1, arg2, arg3) {
  const options = parseQueryArgs(arg1, arg2, arg3);
  return createBaseQuery(options, InfiniteQueryObserver);
}

// node_modules/@tanstack/svelte-query/build/lib/createMutation.js
function createMutation(arg1, arg2, arg3) {
  const options = parseMutationArgs(arg1, arg2, arg3);
  const queryClient = useQueryClient();
  let observer = new MutationObserver(queryClient, options);
  let mutate;
  readable(observer).subscribe(($observer) => {
    observer = $observer;
    mutate = (variables, mutateOptions) => {
      observer.mutate(variables, mutateOptions).catch(noop);
    };
    observer.setOptions(options);
  });
  const result = readable(observer.getCurrentResult(), (set) => {
    return observer.subscribe(notifyManager.batchCalls((val) => set(val)));
  });
  const { subscribe } = derived(result, ($result) => ({
    ...$result,
    mutate,
    mutateAsync: $result.mutate
  }));
  return { subscribe };
}
function noop() {
}

// node_modules/@tanstack/svelte-query/build/lib/useIsFetching.js
function useIsFetching(arg1, arg2) {
  const [filters] = parseFilterArgs(arg1, arg2);
  const client = useQueryClient();
  const cache = client.getQueryCache();
  let isFetching = client.isFetching(filters);
  const { subscribe } = readable(isFetching, (set) => {
    return cache.subscribe(notifyManager.batchCalls(() => {
      const newIsFetching = client.isFetching(filters);
      if (isFetching !== newIsFetching) {
        isFetching = newIsFetching;
        set(isFetching);
      }
    }));
  });
  return { subscribe };
}

// node_modules/@tanstack/svelte-query/build/lib/useIsMutating.js
function useIsMutating(arg1, arg2) {
  const [filters] = parseMutationFilterArgs(arg1, arg2);
  const client = useQueryClient();
  const cache = client.getMutationCache();
  let isMutating = client.isMutating(filters);
  const { subscribe } = readable(isMutating, (set) => {
    return cache.subscribe(notifyManager.batchCalls(() => {
      const newIisMutating = client.isMutating(filters);
      if (isMutating !== newIisMutating) {
        isMutating = newIisMutating;
        set(isMutating);
      }
    }));
  });
  return { subscribe };
}

// node_modules/@tanstack/svelte-query/build/lib/useHydrate.js
function useHydrate(state, options) {
  const client = useQueryClient();
  if (state) {
    hydrate(client, state, options);
  }
}

// node_modules/@tanstack/svelte-query/build/lib/Hydrate.svelte
function create_fragment(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Hydrate", slots, ["default"]);
  let { state } = $$props;
  let { options = void 0 } = $$props;
  useHydrate(state, options);
  $$self.$$.on_mount.push(function() {
    if (state === void 0 && !("state" in $$props || $$self.$$.bound[$$self.$$.props["state"]])) {
      console.warn("<Hydrate> was created without expected prop 'state'");
    }
  });
  const writable_props = ["state", "options"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Hydrate> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("state" in $$props2)
      $$invalidate(0, state = $$props2.state);
    if ("options" in $$props2)
      $$invalidate(1, options = $$props2.options);
    if ("$$scope" in $$props2)
      $$invalidate(2, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({ useHydrate, state, options });
  $$self.$inject_state = ($$props2) => {
    if ("state" in $$props2)
      $$invalidate(0, state = $$props2.state);
    if ("options" in $$props2)
      $$invalidate(1, options = $$props2.options);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [state, options, $$scope, slots];
}
var Hydrate = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, { state: 0, options: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Hydrate",
      options,
      id: create_fragment.name
    });
  }
  get state() {
    throw new Error("<Hydrate>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set state(value) {
    throw new Error("<Hydrate>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get options() {
    throw new Error("<Hydrate>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set options(value) {
    throw new Error("<Hydrate>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Hydrate_default = Hydrate;

// node_modules/@tanstack/svelte-query/build/lib/QueryClientProvider.svelte
function create_fragment2(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[1],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[1],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[1]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[1],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("QueryClientProvider", slots, ["default"]);
  let { client = new QueryClient() } = $$props;
  onMount(() => {
    client.mount();
  });
  setQueryClientContext(client);
  onDestroy(() => {
    client.unmount();
  });
  const writable_props = ["client"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<QueryClientProvider> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("client" in $$props2)
      $$invalidate(0, client = $$props2.client);
    if ("$$scope" in $$props2)
      $$invalidate(1, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    onDestroy,
    onMount,
    QueryClient,
    setQueryClientContext,
    client
  });
  $$self.$inject_state = ($$props2) => {
    if ("client" in $$props2)
      $$invalidate(0, client = $$props2.client);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [client, $$scope, slots];
}
var QueryClientProvider = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment2, safe_not_equal, { client: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "QueryClientProvider",
      options,
      id: create_fragment2.name
    });
  }
  get client() {
    throw new Error("<QueryClientProvider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set client(value) {
    throw new Error("<QueryClientProvider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var QueryClientProvider_default = QueryClientProvider;
export {
  CancelledError,
  Hydrate_default as Hydrate,
  InfiniteQueryObserver,
  MutationCache,
  MutationObserver,
  QueriesObserver,
  Query,
  QueryCache,
  QueryClient,
  QueryClientProvider_default as QueryClientProvider,
  QueryObserver,
  createInfiniteQuery,
  createMutation,
  createQueries,
  createQuery,
  defaultShouldDehydrateMutation,
  defaultShouldDehydrateQuery,
  dehydrate,
  focusManager,
  getQueryClientContext,
  hashQueryKey,
  hydrate,
  isCancelledError,
  isError,
  isServer,
  matchQuery,
  notifyManager,
  onlineManager,
  parseFilterArgs,
  parseMutationArgs,
  parseMutationFilterArgs,
  parseQueryArgs,
  replaceEqualDeep,
  setQueryClientContext,
  useHydrate,
  useIsFetching,
  useIsMutating,
  useQueryClient
};
//# sourceMappingURL=@tanstack_svelte-query.js.map
